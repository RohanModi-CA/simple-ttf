#include <math.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <stdbool.h>

/*
 * We want to take a TTF file, and then generate pixel arrays.
 * We note that TTF is a Big-Endian file format, so we have to
 * reverse the Endianness to read on a standard little Endian
 * unix system.
 */ 


/*
 * We assume that our TTF files contain EBDT and EBLC tables. Unfortunately,
 * most TTF files do not. However, they can be generated by FontForge.
 * Perhaps we can call a shell script to do that automatically with FontForge.
 */


// Reverse the byte order. Takes a pointer to the value and its size in bytes.
static void *fix_endianness(void *value, size_t bytes)
{
	// First, let's make an intermediary variable.
	char *intermediary = (char *) malloc(bytes);

	// Copy it in, backwards.
	for (int i=0; i<bytes; ++i)
	{
		// We cast each byte to char.
		intermediary[i] = ((char *) value)[bytes - 1 - i];
	}

	// Now overwrite.
	for (int i=0; i<bytes; ++i)
	{
		((char *) value)[i] = intermediary[i];
	}

	// And delete the intermediary
	free(intermediary);

	return value;
}

struct header_contents
{
	int offset_cmap;
	int offset_EBLC;
	int offset_EBDT;
	int length_cmap;
	int length_EBLC;
	int length_EBDT;	
};

// This assumes there are no segments with a nonzero id_range_offset.
struct cmap_indices
{
	uint16_t segcountX1;
	uint16_t *endcodes;
	uint16_t *startcodes;
	uint16_t *id_deltas;
};

struct EBLC_information
{
	uint32_t image_data_offset;
	uint32_t index_form1_sbit_offset;
	uint16_t image_format;
	uint16_t index_format;
	uint32_t index_form2_image_size;
	uint32_t image_form5_bitmap_offset;
	uint8_t  embedded_metrics_height;
	uint8_t  embedded_metrics_width;
};

struct TTF_info
{
	struct header_contents header;
	struct cmap_indices cmap;
	struct EBLC_information eblc;
	FILE *fp;
};

struct pixel_data
{
	uint16_t width;
	uint16_t height;
	uint16_t bytes_to_read;
	uint8_t *pixel_data;

};

static struct header_contents S_TTF_read_header(FILE *fp)
{
	// Our first course of action is to check that both the EBLC (locations)
	// and the EBDT (data) tables are actually present. We will read the header.

	// We're in the offset header, whose first four bytes are the version number. This should
	// be zero. We will verify this.
	int version_number;
	fread(&version_number, 4, 1, fp);
	fix_endianness(&version_number, sizeof(int));

	// We are coding for regular TrueType fonts.
	if (version_number != 65536)
	{
		fprintf(stderr, "simple_ttf: Noncompatible TTF file version. Exiting.\n");
		exit(1);
	}

	// The bytes 0x04-0x05 contain the number of tables, which is what we're interested in.
	u_int16_t num_tables;
	fseek(fp, 4, SEEK_SET);
	fread(&num_tables, sizeof(uint16_t), 1, fp);
	fix_endianness(&num_tables, 2);

	struct header_contents header;

	header.offset_cmap = -1; header.offset_EBLC = -1; header.offset_EBDT = -1;
	header.length_cmap = -1; header.length_EBLC = -1; header.length_EBDT = -1;	

	{ // This section reads the tables.
		// Now let's read the names of each table.
		// We are interested in the CMAP, EBLC, and EBDT tables
		// to extract bitmaps.
		int start_of_tables = 12;
		char table_name[5]; table_name[4]='\0';
		int table_checksum;
		int table_offset;
		int table_length;

		// Go to the start of the first table. 
		fseek(fp, start_of_tables, SEEK_SET);
		for (int i=0; i<num_tables; ++i)
		{
			// Each table is 16 bytes, 4 each:
			// name, checksum, offset, length.
			fread(&table_name, 1, 4, fp);
			fread(&table_checksum, 4, 1, fp);
			fread(&table_offset, 4, 1, fp);
			fread(&table_length, 4, 1, fp);

			fix_endianness(&table_checksum, 4);
			fix_endianness(&table_offset, 4);
			fix_endianness(&table_length, 4);

			// fread automatically advances the file.

			if(strcmp(table_name, "cmap")==0)
			{
				header.offset_cmap = table_offset;
				header.length_cmap = table_length;
			}
			else if (strcmp(table_name, "EBLC")==0)
			{
				header.offset_EBLC = table_offset;
				header.length_EBLC = table_length;
			}
			else if (strcmp(table_name,  "EBDT")==0)
			{
				header.offset_EBDT = table_offset;
				header.length_EBDT = table_length;
			}
			//printf("%s\n", table_name);
		}

	} // Reading each of the tables. 
	
	// If the tables were not found, exit.
	if((header.offset_cmap == -1) || (header.offset_EBDT == -1) || (header.offset_EBLC == -1) || 
		(header.length_cmap == -1) || (header.length_EBLC == -1) || (header.length_EBDT == -1))
	{
		fprintf(stderr, "simple_ttf: cmap, EBLC, or EBDT table not found. Exiting.\n");
		fprintf(stderr, "simple_ttf: (this font is probably not bitmapped). \n");
		exit(1);
	}

	return header;
}

static struct cmap_indices parse_cmap(struct header_contents header, FILE *fp)
{
	struct cmap_indices output;

	// Let's go to the start of cmap.
	fseek(fp, header.offset_cmap, SEEK_SET);
	
	// The first two bytes are the version, which must be zero. Confirm:
	uint16_t cmap_version;
	fread(&cmap_version, 2, 1, fp);
	if (cmap_version != 0)
	{
		fprintf(stderr, "simple_ttf: Noncompatible cmap version. Exiting.\n");
		exit(1);
	}

	// The next two bytes are the number of encoding tables. 
	uint16_t num_of_encoding_tables;
	fread(&num_of_encoding_tables, 2, 1, fp);
	fix_endianness(&num_of_encoding_tables, 2);

	// Now, let's parse each of those.
	uint16_t platform_id, encoding_id;
	uint32_t relative_offset;
	{ // Here, we search for the Unicode2.0 mappings
		bool found = false;
		for(int i=0; i<num_of_encoding_tables; ++i)
		{
			fread(&platform_id, 2, 1, fp);
			fread(&encoding_id, 2, 1, fp);
			fread(&relative_offset, 4, 1, fp);
			fix_endianness(&platform_id, 2); fix_endianness(&encoding_id, 2);
			fix_endianness(&relative_offset, 4);

			// We're only going to deal with the Unicode 2.0 mappings.
			if(encoding_id==3 && platform_id==0)
			{
				found = true;
				break;
			}
		}
		if (!found)
		{
			fprintf(stderr, "simple_ttf: cmap does not contain Unicode2.0 mappings. Exiting.");
			exit(1);
		}
	} // End searching for Unicode2.0 mappings.

	// We move to the start of the Unicode2.0 subtable.
	fseek(fp, header.offset_cmap + relative_offset, SEEK_SET);
	
	{ // Here, we handle the subtable.
		// Now let's ensure we are in Format 4.
		uint16_t subtable_format;
		fread(&subtable_format, 2, 1, fp);
		fix_endianness(&subtable_format, 2);
		if (subtable_format != 4)
		{
			fprintf(stderr, "simple_ttf: cmap subtable not of format 4. Exiting.\n");
			exit(1);
		}

		/*
		 * The structure is as follows:
		 * 0x00-0x01: Format
		 * 0x02-0x03: Total subtable length
		 * 0x04-0x05: language code
		 * 0x06-0x07: segcount times two
		 * 0x08-0x13: Binary search tools
		 */

		uint16_t length, language_code, segcountX2;
		fread(&length, 2, 1, fp);
		fread(&language_code, 2, 1, fp);
		fread(&segcountX2, 2, 1, fp);
		fix_endianness(&length, 2);
		fix_endianness(&language_code, 2);
		fix_endianness(&segcountX2, 2);
		fseek(fp, 6, SEEK_CUR);
		
		/*
		 * The structure from here is as follows:
		 * uint16_t endCode[segcount]
		 * uint16_t reserved_pad
		 * uint16_t startCode[segcount]
		 * int16_t idDelta[segcount]
		 * uint16_t idRangeOffset[segcount]
		 */

		output.segcountX1 = segcountX2 / 2;
		output.endcodes = (uint16_t*) malloc(segcountX2);
		output.startcodes = (uint16_t*) malloc(segcountX2);
		output.id_deltas = (uint16_t*) malloc(segcountX2); 

		for (int i=0; i<segcountX2; i+=2)
		{
			fread(&(output.endcodes[i]), 2, 1, fp);
			fix_endianness(&(output.endcodes[i]), 2);
		}

		// Skip the reserved_pad
		fseek(fp, 2, SEEK_CUR);

		for (int i=0; i<segcountX2; i+=2)
		{
			fread(&(output.startcodes[i]), 2, 1, fp);
			fix_endianness(&(output.startcodes[1]), 2);
		}

		for (int i=0; i<segcountX2; i+=2)
		{
			fread(&(output.id_deltas[i]), 2, 1, fp);
			fix_endianness(&(output.id_deltas[i]), 2);
		}

		{ // We will not currently support id_range_offset == 1. Check.
			uint16_t id_range_offset;
			for (int i=0; i<segcountX2; i+=2)
			{
				fread(&id_range_offset, 2, 1, fp);
				fix_endianness(&id_range_offset, 2);
				if (id_range_offset != 0)
				{
					fprintf(stderr, "simple_ttf: nonzero id_range_offset not supported. Exiting.\n");
					exit(1);
				}
			}
		} // End verifying that all id_range_offset are zero.

	} // End parsing the subtable.

	return output;
}

static uint16_t glyph_index(char c, struct cmap_indices cmap)
{
	// First we need to locate the char. We will do a basic search.
	// First we will find the endcode above the char, most near to it.
	// Then we will check to verify that the startCode most near to it is at the same index.
	
	uint16_t c_int = (uint16_t) c;
	uint16_t c_segment;
	uint16_t glyph_index;

	{ // Search for the correct segment
		uint16_t closest_endcode_i = 0;
		uint16_t closest_startcode_i = 0;

		for(int i=0; i<cmap.segcountX1; ++i)
		{
			if(cmap.endcodes[i] >= c_int && 
					cmap.endcodes[i] < cmap.endcodes[closest_endcode_i])
			{
				closest_endcode_i = i;
			}

			if(cmap.startcodes[i] <= c_int && 
					cmap.startcodes[i] > cmap.startcodes[closest_startcode_i])
			{
				closest_startcode_i = i;
			}
		}

		if (closest_endcode_i != closest_startcode_i)
		{
			fprintf(stderr, "simple_ttf: error finding the segment for char %c. Exiting.\n", c);
			exit(1);
		}

		c_segment = closest_endcode_i;
	} // End searching for the correct segment
	
	glyph_index = c_int + cmap.id_deltas[c_segment];
	return glyph_index;
}

static struct EBLC_information parse_EBLC(uint16_t glyph_index, uint8_t font_px, struct header_contents header, FILE *fp)
{
	fseek(fp, header.offset_EBLC, SEEK_SET);
	
	{ // Check version numbers are in order.
		uint16_t major_version, minor_version;
		fread(&major_version, 2, 1, fp);
		fread(&minor_version, 2, 1, fp);
		fix_endianness(&major_version, 2);
		fix_endianness(&minor_version, 2);

		if(!(major_version == 2 && minor_version ==0))
		{
			fprintf(stderr, "simple_ttf: unsupported EBLC table version. Exiting.\n");
			exit(1);
		}
	} // End checking version numbers

	uint32_t num_of_bitmap_sizes;
	fread(&num_of_bitmap_sizes, 4, 1, fp);
	fix_endianness(&num_of_bitmap_sizes, 4);

	/*
	 * After this starts each 48 byte long bitmapsize record.
	 * We want to first find the correct bitmapsize record for this font strike size.
	 * There is only one record per strike size. We will also verify that the 
	 * glyph index is also in the provided range.
	*/
	uint32_t index_subtable_array_offset;
	uint32_t index_subtable_array_size;
	uint32_t number_of_index_subtables;
	uint32_t correct_subtable_index;
	{ // Finding the correct bitmapsize record
		uint32_t colorref_reserved;
		// Skip 24 bytes.
		uint16_t start_glyph_index;
		uint16_t end_glyph_index;
		uint8_t ppemX;
		uint8_t ppemY;
		uint8_t bit_depth;
		uint8_t flags;

		bool found=false;
		for (int i=0; i<num_of_bitmap_sizes; ++i)
		{
			fread(&index_subtable_array_offset, 4, 1, fp);
			fread(&index_subtable_array_size, 4, 1, fp);
			fread(&number_of_index_subtables, 4, 1, fp);
			fread(&colorref_reserved, 4, 1, fp);
			fseek(fp, 24, SEEK_CUR);
			fread(&start_glyph_index, 2, 1, fp);
			fread(&end_glyph_index, 2, 1, fp);
			fread(&ppemX, 1, 1, fp);
			fread(&ppemY, 1, 1, fp);
			fread(&bit_depth, 1, 1, fp);
			fread(&flags, 1, 1, fp);
			fix_endianness(&index_subtable_array_offset, 4);
			fix_endianness(&index_subtable_array_size, 4);
			fix_endianness(&number_of_index_subtables, 4);
			fix_endianness(&colorref_reserved, 4);
			fix_endianness(&start_glyph_index, 2);
			fix_endianness(&end_glyph_index, 2);
			
			if(ppemY != font_px)
			{
				continue;
			}

			if(colorref_reserved != 0)
			{
				fprintf(stderr, "simple_ttf: damaged EBLC table. Exiting.\n");
				exit(1);
			}

			if (!(start_glyph_index <= glyph_index && glyph_index <= end_glyph_index))
			{
				fprintf(stderr, "simple_ttf: no %hu glyph found in %u pt font. Exiting.\n", glyph_index, font_px);
				exit(1);
			}

			// We found it.
			correct_subtable_index = i;
			found = true;
		}

		if (!found)
		{
			fprintf(stderr, "simple_ttf: unable to find the desired %u font pt. Exiting.\n", font_px);
			exit(1);
		}
	} // End Finding the correct bitmapsize record.
	
	// Go to the corresponding index_subtable_array_offset.
	fseek(fp, header.offset_EBLC + index_subtable_array_offset, SEEK_SET);

	/* This is just an array of index_subtable records, which goes:
	 * uint16_t firstGlyphIndex
	 * uint16_t lastGlyphIndex
	 * uint32_t index_subtable_offset
	 * Notably: 
	 * Records must be sorted by firstGlyphIndex, and records should not have overlapping glyph ID ranges.
	 */

	// This offset is from the start of the index_subtable_array.
	uint32_t correct_index_subtable_offset;
	uint16_t correct_first_glyph_index;
	{ // Finding the correct index_subtable
		uint16_t last_glyph_index;
		uint32_t correct_subtable_index;
		bool found = false;

		// Check each interval to see if the glyph index is inside.
		for(int i=0; i<number_of_index_subtables; ++i)
		{
			fread(&correct_first_glyph_index, 2, 1, fp);
			fread(&last_glyph_index, 2, 1, fp);
			fread(&correct_index_subtable_offset, 4, 1, fp);
			fix_endianness(&correct_first_glyph_index, 2);
			fix_endianness(&last_glyph_index, 2);
			fix_endianness(&correct_index_subtable_offset, 4);
			
			if(correct_first_glyph_index <= glyph_index && glyph_index <= last_glyph_index)
			{
				found = true;
				break;
			}
		}
		if (!found)
		{
			fprintf(stderr, "simple_ttf: glyph_index not found within the index_subtable. Exiting.\n");
			exit(0);
		}
	} // End Finding the correct index_subtable
	
	// Go to the correct_index_subtable.
	fseek(fp, header.offset_EBLC + index_subtable_array_offset + correct_index_subtable_offset, SEEK_SET);

	// We need to now get the offset into the EBDT table. 
	struct EBLC_information output;
	{ // Parse the index subtable
		// Index subtable record is 2 uint16s, index_format and image_format, and a uint32, image_data_offset.
		fread(&output.index_format, 2, 1, fp);
		fread(&output.image_format, 2, 1, fp);
		fread(&output.image_data_offset, 4, 1, fp);
		fix_endianness(&output.index_format, 2);
		fix_endianness(&output.image_format, 2);
		fix_endianness(&output.image_data_offset, 4);

		// Format 1 is the most common, so let's stick with that.
		if (!(output.index_format == 1 || output.index_format == 2 ))
		{
			fprintf(stderr, "simple_ttf: index subtable has index_format %hu, which is not supported. Exiting.\n", output.index_format);
			exit(1);
		}

		
		if(output.image_format == 1)
		{
			// Now, all we must do is get the EBDT offset.
			uint32_t sbit_offset_array_index = glyph_index - correct_first_glyph_index;
			fseek(fp, 4*sbit_offset_array_index, SEEK_CUR);
			fread(&output.index_form1_sbit_offset, 4, 1, fp);
			fix_endianness(&output.index_form1_sbit_offset, 4);
		}

		// If it is format 2
		if(output.index_format == 2)
		{
			fread(&output.index_form2_image_size, 4, 1, fp);
			fix_endianness(&output.index_form2_image_size, 4);
			output.image_form5_bitmap_offset = output.image_data_offset + (glyph_index - correct_first_glyph_index) * output.index_form2_image_size;

			// Now let's read the first two entries off of the BigGlyphsMetricsRecord which follows.
			fread(&output.embedded_metrics_height, 1, 1, fp);
			fread(&output.embedded_metrics_width, 1, 1, fp);
		}

	} // End parsing the index subtable
	
	return output;
}




static struct pixel_data read_EBDT(struct EBLC_information eblc, struct header_contents header, FILE *fp)
{
	fseek(fp, header.offset_EBDT, SEEK_SET);
	{ // Check versioning
		uint16_t major_version;
		uint16_t minor_version;
		fread(&major_version, 2, 1, fp);
		fread(&minor_version, 2, 1, fp);
		fix_endianness(&major_version, 2);
		fix_endianness(&minor_version, 2);

		if(!(major_version == 2 && minor_version == 0))
		{
			fprintf(stderr, "simple_ttf: unsupported EBDT versions. Exiting.\n");
			exit(1);
		}
	} // End Checking versioning
	
	if (eblc.index_format == 1)
	{
		// Let's go to the correct spot in the EBDT table.
		fseek(fp, header.offset_EBDT +  eblc.image_data_offset + eblc.index_form1_sbit_offset, SEEK_SET);

		// We will handle image format 2 and image format 7 for now.
		if (!(eblc.image_format == 2 || eblc.image_format == 7))
		{
			fprintf(stderr, "simple_ttf: Image format %hu in EBDT is unsupported for index format 1. Exiting.\n", eblc.image_format);
			exit(1);
		}

		// Prepare the output
		struct pixel_data out;

		{ // Read the MetricsRecords, Small for format 2, Large for 7.
			if (eblc.image_format == 2)
			{ // Reading the SmallGlyphMetricsRecord
				int8_t bearingX;
				int8_t bearingY;
				uint8_t advance;

				fread(&out.height, 1, 1, fp);
				fread(&out.width, 1, 1, fp);
				fread(&bearingX, 1, 1, fp);
				fread(&bearingY, 1, 1, fp);
				fread(&advance, 1, 1, fp);
			} // End Reading the SmallGlyphMetricsRecord.

			else if (eblc.image_format == 7)
			{
				fread(&out.height, 1, 1, fp);
				fread(&out.width, 1, 1, fp);	

				fseek(fp, 6, SEEK_CUR);
			}


		} // End read the MetricsRecords.
		
		// Now, we need to actually read the bits. There are bmp_width columns and out.height rows.
		// The rows are placed sequentially, and do not wait for byte boundaries.

		// We just need to extract all the data. We know there is bmp_width * out.height pixels, and we need
		// to ensure it is divisible by 8 to fit in a byte.
		out.bytes_to_read = ceil( (float)(out.width*out.height)/8.0f );
		out.pixel_data = (uint8_t*) malloc(out.bytes_to_read);
		
		fread(out.pixel_data, 1, out.bytes_to_read, fp);
	return out;
	} // end eblc.index_format == 1

	else if(eblc.index_format == 2)
	{
		struct pixel_data out;
		{ // We only handle image formats 5 and 7. Check.
			if (!(eblc.image_format == 5 || eblc.image_format == 17))

			{
				fprintf(stderr,"simple_ttf.read_EBDT: image_format %hu unsupported for index format 2. Exiting.\n", eblc.image_format);
				exit(1);
			}
		} // End checking for image format 5 and 7.

		// Go to the correct spot in the EBDT table.
		{
			if(eblc.image_format == 5)
			{
				// Get the Metrics from the embedded ones from EBLC.
				out.height = eblc.embedded_metrics_height;
				out.width  = eblc.embedded_metrics_width;

				fseek(fp, header.offset_EBDT + eblc.image_form5_bitmap_offset, SEEK_SET);
			}
			else if (eblc.image_format == 7)
			{
				fseek(fp, header.offset_EBDT + eblc.image_form5_bitmap_offset, SEEK_SET);

				// A BigGlyphsMetricsRecord is 8 (u)int8_ts.
				fread(&out.height, 1, 1, fp);
				fread(&out.width, 1, 1, fp);
				fseek(fp, 6, SEEK_CUR);
			}
		} // End going to the start of the image data array


		// Now, let's read the image data into an array, which we know should be image size long.
		// This is *not* affected by endianness, since each byte is considered independant.

		out.bytes_to_read = eblc.index_form2_image_size;
		out.pixel_data = (uint8_t *) malloc(out.bytes_to_read);
		fread(out.pixel_data, 1, out.bytes_to_read, fp);


		



	return out;
	} // End eblc.index_format == 2.

	else 
	{
		fprintf(stderr, "simple_ttf.read_EBDT: index_format %hu not supported. Exiting.\n", eblc.index_format);
		exit(1);
	}
	


}

static void print_binary(uint8_t *pd, uint16_t bytes_to_read)
{
	uint8_t byte;
	uint32_t binary_text;
	for(int i=0; i<bytes_to_read; ++i)
	{
		binary_text = 0;
		byte = pd[i];
		for(int j=7; j>=0;--j)
		{
			if (byte >= (1<<j))
			{
				binary_text += (uint32_t) pow(10, j);
				byte -= (1u<<j);
			}
		}
		
		printf("%08u ", binary_text);
	}
	printf("\n");
}

// Takes an array of bytes, a zero indexed bit number, and the value of the bit.
static void set_bit(uint8_t *pd, uint64_t bit_number, bool bit)
{
	// First, let's find the correct byte.
	uint32_t correct_byte = (bit_number/8); // This truncates down.
	// Now, let's find the bit position.
	uint8_t bit_of_byte = bit_number % 8;
	
	uint8_t comparison_byte_true = (0b10000000 >> bit_of_byte);
	uint8_t comparison_byte_false = ~comparison_byte_true;

	if (!bit)
	{
		pd[correct_byte] &= comparison_byte_false;
	}
	else 
	{
		pd[correct_byte] |= comparison_byte_true;
	}
}

static bool get_bit(uint8_t *pd, uint64_t bit_number)
{
	// First we will navigate to the byte we are interested in. 
	uint64_t byte = bit_number/8; // truncates.
	uint8_t bit_num = bit_number % 8;

	// Let's create our comparison bit.
	uint8_t comparison_byte = 0b10000000 >> bit_num;
	uint8_t compared = comparison_byte & pd[byte];
	
	return (bool) (compared > 0);
}

// Takes a pixel_data struct and an integer height (px/bits). This will fill the pixel data with 0s to the height limit.
static void pad_pd_to_height(struct pixel_data pd, uint16_t height)
{
	uint16_t rows_to_fill = height - pd.height;
	uint16_t new_bytes = ceil(((float)(height * pd.width))/8.0);
	
	// Declare a new, temporary byte array. Initialize with zeros.
	uint8_t *temp = (uint8_t*) calloc(new_bytes, 1);

	// The new blank rows take rows_to_fill * pd.width bits.
	// From here, we just need to copy the existing bits.
	uint16_t start = rows_to_fill * pd.width;
	uint16_t old_bits = pd.width * pd.height;
	for(int i=0; i<old_bits; ++i)
	{
		(temp[start+i]) = get_bit(pd.pixel_data, i);
	}
	// And the remaining bits are left as zeros from calloc.
	free(pd.pixel_data);
	pd.pixel_data = temp;
	return;
}


// This will take an array of pixel_datas, all of which are at the same height. Then, it will create
// a new pixel data, smush them all together, and free the input. Additionally, takes the letter_tracking (spacing between each letter, in pixels).
static struct pixel_data smush_pds(struct pixel_data *pd_array, uint16_t how_many, uint8_t letter_tracking)
{
	uint16_t summed_width = 0;
	{ // Check the heights are equal, and sum up the widths (including the tracking).
		for (int i=0; i<how_many; ++i)
		{
			if(pd_array[i].height != pd_array[0].height)
			{
				fprintf(stderr, "simple_ttf: smush_pds requres an array of pixel datas at the same height. Exiting.");
				exit(1);
			}
			summed_width += (pd_array[i].width + letter_tracking);
		}
	} // End checking height equality and summing widths.
	
	// Now, the output, in bits, will be the width times the height. We need that in bytes.
	uint32_t bytes_out = ceil(((double) summed_width * pd_array[0].height)/8.0);
	struct pixel_data out; out.height = pd_array[0].height; out.width = summed_width;
	out.pixel_data = (uint8_t *) calloc(1, bytes_out);

	uint16_t previous_bit_owner_index;
	uint16_t previous_bit_owner_col;
	{ // Now, we must fill in the new pixel array, going line by line, and then, bit by bit.
		for (int row=0; row<out.height; ++row)
		{
			previous_bit_owner_index=0;
			previous_bit_owner_col=0;

			// Now, iterate through the bits. The bits start at current_row * columns
			for(int bit=row*out.width; bit<((row+1)*out.width); ++bit)
			{

				/* From here, we need to decide how to identify which bit to take, from which
				 * pixel array. We will check if the previous_bit_owner_index has 
				 * previous_bit_owner_col columns. If so, we skip and move on.
				 */

				if (previous_bit_owner_col == pd_array[previous_bit_owner_index].width)
				{
					// Move on by resetting that column to zero, and moving forward the index.
					previous_bit_owner_col = 0;
					++previous_bit_owner_index;


					// Check to ensure we don't read out of bounds.
					if(previous_bit_owner_index >= how_many)
					{
						// Just go to the next row. 
						break;
					}

					// To add the letter tracking, we just skip forward by letter tracking bits,
					// since the out array is calloc'ed to zeros. 
					// Note that the loop itself will skip one here, so we skip (letter_tracking-1) bits.
					bit += letter_tracking - 1;
				}
				else
				{
					set_bit(out.pixel_data, bit, 
							get_bit(pd_array[previous_bit_owner_index].pixel_data,
								row*pd_array[previous_bit_owner_index].width + previous_bit_owner_col));
					++previous_bit_owner_col;
				}

				

			}

		} // End of Rows Loop.
	} // End of filling in the new pixel array.

	// Finally, we free all of the input arrays.
	for(int i=0; i<how_many; ++i)
	{
		free(pd_array[i].pixel_data);
	}
	free(pd_array);

	return out;
}















struct byte_data
{
	uint8_t width;
	uint8_t height;
	uint8_t *color_map;
};





/* This takes a struct pixel_data and converts it to a width*height byte array of uint8_t 
 * made of the parameter on and offs. */
struct byte_data convert_to_bytes(struct pixel_data pd, uint8_t on, uint8_t off)
{
	struct byte_data bd;
	bd.color_map = (uint8_t*) malloc(pd.height * pd.width);
	bd.height = pd.height;
	bd.width = pd.width;

	for(int i=0; i<pd.height * pd.width; ++i)
	{
		if (get_bit(pd.pixel_data, i))
		{
			bd.color_map[i] = on;
		}
		else 
		{
			bd.color_map[i] = off;
		}
	}
	return bd;
}

void normalize_byte_data_height(struct byte_data *bd, uint8_t off, uint8_t height)
{
	if(height<bd->height)
	{
		fprintf(stderr, "simple_ttf: Invalid normalization height. Exiting. \n");
		exit(1);
	}
	
	uint8_t *temp_bd = (uint8_t *) malloc(height * bd->width);
	memset(temp_bd, off, (height-bd->height)*bd->width);
	memcpy(temp_bd + (height-bd->height)*bd->width, bd->color_map, bd->height * bd->width);

	bd->height = height;
	free(bd->color_map);
	bd->color_map = temp_bd;

	return;
}

void normalize_byte_data_width(struct byte_data *bd, uint8_t off, uint8_t width)
{
	{ // Check the new width isn't larger than the old.
		if(width < bd->width)
		{
			fprintf(stderr, "simple_ttf: can't normalize to be smaller. Exiting.\n");
			exit(1);
		}
	} // End checking dimensions.
	
	/*
	 * We will start by allocating the new array. Then, we memset it to off. 
	 * Then, we iterate through each row of the new one, memcpying the old stuff in the "middle".
	 * If we are adding an odd number of columns, we want the extra column to go on the right of the letter.
	 * Thus, the column index of our startpoint is just (cols_to_add) // 2.
	 */

	uint8_t *temp = (uint8_t *) malloc(bd->height * width);
	memset(temp, off, bd->height * width);
	
	int cols_to_add = width - bd->width;
	int col_start_point = cols_to_add / 2;
	for(int row=0; row<bd->height; ++row)
	{
		int dest_row_start_index = row * width;
		memcpy(temp + dest_row_start_index + col_start_point, bd->color_map + row*bd->width, bd->width);
	}

	free(bd->color_map);
	bd->color_map = temp;
	bd->width = width;
}



void generate_file(const char *filename, int font_px)
{
	/* We will go through all characters between 32( ) and 126(~), extract their bitmaps.
	 * We will convert them to a common height. We will then ensure they all are 
	 * of the same width. Assuming that is the case, we will make our record which is:
	 * uint8_t height, uint8_t width, uint8_t bitmaps[(126-32 + 1)*height*width] */
	
	FILE *fp = fopen(filename, "rb");
	if (!fp)
	{
		fprintf(stderr, "simple_ttf: failed to open %s. \n", filename);
		exit(1);
	}
	struct header_contents header = S_TTF_read_header(fp);
	struct cmap_indices cmap =  parse_cmap(header, fp);



	// Now let's iterate through, and start getting the pixel datas. At this point, we only want to do two things:
	// 1.) Find the largest height, so that we can normalize them. 2.) Find the largest width, should we require normalization.
	uint8_t largest_height = 0;
	uint8_t largest_width = 0;
	for (char c=32; c<=126; ++c)
	{
		uint16_t glyph = glyph_index(c, cmap);
		struct EBLC_information eblc = parse_EBLC(glyph, font_px, header, fp);
		struct TTF_info ttf = {header, cmap, eblc, fp};
		struct pixel_data pd = read_EBDT(eblc, header, fp);


		if(pd.height > largest_height){largest_height = pd.height;}
		if(pd.width  > largest_width) {largest_width  = pd.width; }

		free(pd.pixel_data);
	}

	{// Ensure the largest height doesn't exceed the font_px
		if (largest_height > font_px)
		{
			fprintf(stderr, "simple_ttf: font has char whose height exceeds strike. Exiting. \n");
			exit(1);
		}
	} // End ensure the largest height doesn't exceed font_px.
	
	// Force it to be the expected height. 
	largest_height = font_px;

	/* Now, we will just normalize everything, and add all of the byte data uint8_t arrays
	 * to another 1d array, the bitmaps array, as described above. The index of each array is just
	 * (char c - 32) * largest_width * largest_height.
	 * */

	uint8_t *bitmaps = (uint8_t *) malloc((126-32 +1) * largest_height * largest_width);
	for(char c=32; c<=126; ++c)
	{
		uint16_t glyph = glyph_index(c, cmap);
		struct EBLC_information eblc = parse_EBLC(glyph, font_px, header, fp);
		struct TTF_info ttf = {header, cmap, eblc, fp};
		struct pixel_data pd = read_EBDT(eblc, header, fp);
	
		struct byte_data bd = convert_to_bytes(pd, 0, 255);
		normalize_byte_data_height(&bd, 255, largest_height);
		normalize_byte_data_width(&bd, 255, largest_width);
		
		int bitmap_index = (c-32) * largest_width * largest_height;
		memcpy(bitmaps + bitmap_index, bd.color_map, largest_height * largest_width);
		free(bd.color_map);

	}

	// Print each char
	/*
	for(char c=0; c<(126-32 + 1); ++c)
	{
		printf("Char %c: \n", c+32);
		for (int row=0; row<largest_height; ++row)
		{
			for(int col=0; col<largest_width; ++col)
			{
				int index = c * (largest_width * largest_height) + row*largest_width + col;
				printf("%u", bitmaps[index]);
			}
			printf("\n");
		}
		printf("\n\n\n");

	}
	*/

	// Now, we need to manually write the array. We will just print it. We can redirect it to a file if need be.
	printf("const uint8_t font[] = { ");
	for(int i=0; i<(126-32 + 1) * largest_height * largest_width; ++i)
	{
		printf("0x%x, ", bitmaps[i]);
	}
	printf("};\n\n");

	printf("const uint8_t font_width = %u;\n", largest_width);
	printf("const uint8_t font_height = %u;\n", largest_height);


	free(bitmaps);
	fclose(fp);

}



void read_ttf(const char *filename)
{
	FILE *fp = fopen(filename, "rb");
	if (!fp)
	{
		fprintf(stderr, "simple_ttf: failed to open %s. \n", filename);
		exit(1);
	}

	struct header_contents header = S_TTF_read_header(fp);
	struct cmap_indices cmap =  parse_cmap(header, fp);
	uint16_t glyph = glyph_index('m', cmap);
	//printf("%hu \n", glyph);
	struct EBLC_information eblc = parse_EBLC(glyph, 8, header, fp);

	struct TTF_info ttf = {header, cmap, eblc, fp};
	struct pixel_data pd = read_EBDT(eblc, header, fp);
	



	fclose(fp);
}




int main()
{
	//read_ttf("resources/Pixolletta8px2.ttf");	
	generate_file("resources/PixelOperatorMono82.ttf", 8);
	


}
