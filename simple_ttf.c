#include <math.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <stdbool.h>

/*
 * We want to take a TTF file, and then generate pixel arrays.
 * We note that TTF is a Big-Endian file format, so we have to
 * reverse the Endianness to read on a standard little Endian
 * unix system.
 */ 


/*
 * We assume that our TTF files contain EBDT and EBLC tables. Unfortunately,
 * most TTF files do not. However, they can be generated by FontForge.
 * Perhaps we can call a shell script to do that automatically with FontForge.
 */


// Reverse the byte order. Takes a pointer to the value and its size in bytes.
static void *fix_endianness(void *value, size_t bytes)
{
	// First, let's make an intermediary variable.
	char *intermediary = (char *) malloc(bytes);

	// Copy it in, backwards.
	for (int i=0; i<bytes; ++i)
	{
		// We cast each byte to char.
		intermediary[i] = ((char *) value)[bytes - 1 - i];
	}

	// Now overwrite.
	for (int i=0; i<bytes; ++i)
	{
		((char *) value)[i] = intermediary[i];
	}

	// And delete the intermediary
	free(intermediary);

	return value;
}

struct header_contents
{
	int offset_cmap;
	int offset_EBLC;
	int offset_EBDT;
	int length_cmap;
	int length_EBLC;
	int length_EBDT;	
};

// This assumes there are no segments with a nonzero id_range_offset.
struct cmap_indices
{
	uint16_t segcountX1;
	uint16_t *endcodes;
	uint16_t *startcodes;
	uint16_t *id_deltas;
};

struct EBLC_information
{
	uint32_t image_data_offset;
	uint32_t sbit_offset;
	uint16_t image_format;
};

struct pixel_data
{
	uint16_t width;
	uint16_t height;
	uint16_t bytes_to_read;
	uint8_t *pixel_data;

};

static struct header_contents S_TTF_read_header(FILE *fp)
{
	// Our first course of action is to check that both the EBLC (locations)
	// and the EBDT (data) tables are actually present. We will read the header.

	// We're in the offset header, whose first four bytes are the version number. This should
	// be zero. We will verify this.
	int version_number;
	fread(&version_number, 4, 1, fp);
	fix_endianness(&version_number, sizeof(int));

	// We are coding for regular TrueType fonts.
	if (version_number != 65536)
	{
		fprintf(stderr, "simple_ttf: Noncompatible TTF file version. Exiting.\n");
		exit(1);
	}

	// The bytes 0x04-0x05 contain the number of tables, which is what we're interested in.
	u_int16_t num_tables;
	fseek(fp, 4, SEEK_SET);
	fread(&num_tables, sizeof(uint16_t), 1, fp);
	fix_endianness(&num_tables, 2);

	struct header_contents header;

	header.offset_cmap = -1; header.offset_EBLC = -1; header.offset_EBDT = -1;
	header.length_cmap = -1; header.length_EBLC = -1; header.length_EBDT = -1;	

	{ // This section reads the tables.
		// Now let's read the names of each table.
		// We are interested in the CMAP, EBLC, and EBDT tables
		// to extract bitmaps.
		int start_of_tables = 12;
		char table_name[5]; table_name[4]='\0';
		int table_checksum;
		int table_offset;
		int table_length;

		// Go to the start of the first table. 
		fseek(fp, start_of_tables, SEEK_SET);
		for (int i=0; i<num_tables; ++i)
		{
			// Each table is 16 bytes, 4 each:
			// name, checksum, offset, length.
			fread(&table_name, 1, 4, fp);
			fread(&table_checksum, 4, 1, fp);
			fread(&table_offset, 4, 1, fp);
			fread(&table_length, 4, 1, fp);

			fix_endianness(&table_checksum, 4);
			fix_endianness(&table_offset, 4);
			fix_endianness(&table_length, 4);

			// fread automatically advances the file.

			if(strcmp(table_name, "cmap")==0)
			{
				header.offset_cmap = table_offset;
				header.length_cmap = table_length;
			}
			else if (strcmp(table_name, "EBLC")==0)
			{
				header.offset_EBLC = table_offset;
				header.length_EBLC = table_length;
			}
			else if (strcmp(table_name,  "EBDT")==0)
			{
				header.offset_EBDT = table_offset;
				header.length_EBDT = table_length;
			}
			//printf("%s\n", table_name);
		}

	} // Reading each of the tables. 
	
	// If the tables were not found, exit.
	if((header.offset_cmap == -1) || (header.offset_EBDT == -1) || (header.offset_EBLC == -1) || 
		(header.length_cmap == -1) || (header.length_EBLC == -1) || (header.length_EBDT == -1))
	{
		fprintf(stderr, "simple_ttf: cmap, EBLC, or EBDT table not found. Exiting.\n");
		fprintf(stderr, "simple_ttf: (this font is probably not bitmapped). \n");
		exit(1);
	}

	return header;
}

static struct cmap_indices parse_cmap(struct header_contents header, FILE *fp)
{
	struct cmap_indices output;

	// Let's go to the start of cmap.
	fseek(fp, header.offset_cmap, SEEK_SET);
	
	// The first two bytes are the version, which must be zero. Confirm:
	uint16_t cmap_version;
	fread(&cmap_version, 2, 1, fp);
	if (cmap_version != 0)
	{
		fprintf(stderr, "simple_ttf: Noncompatible cmap version. Exiting.\n");
		exit(1);
	}

	// The next two bytes are the number of encoding tables. 
	uint16_t num_of_encoding_tables;
	fread(&num_of_encoding_tables, 2, 1, fp);
	fix_endianness(&num_of_encoding_tables, 2);

	// Now, let's parse each of those.
	uint16_t platform_id, encoding_id;
	uint32_t relative_offset;
	{ // Here, we search for the Unicode2.0 mappings
		bool found = false;
		for(int i=0; i<num_of_encoding_tables; ++i)
		{
			fread(&platform_id, 2, 1, fp);
			fread(&encoding_id, 2, 1, fp);
			fread(&relative_offset, 4, 1, fp);
			fix_endianness(&platform_id, 2); fix_endianness(&encoding_id, 2);
			fix_endianness(&relative_offset, 4);

			// We're only going to deal with the Unicode 2.0 mappings.
			if(encoding_id==3 && platform_id==0)
			{
				found = true;
				break;
			}
		}
		if (!found)
		{
			fprintf(stderr, "simple_ttf: cmap does not contain Unicode2.0 mappings. Exiting.");
			exit(1);
		}
	} // End searching for Unicode2.0 mappings.

	// We move to the start of the Unicode2.0 subtable.
	fseek(fp, header.offset_cmap + relative_offset, SEEK_SET);
	
	{ // Here, we handle the subtable.
		// Now let's ensure we are in Format 4.
		uint16_t subtable_format;
		fread(&subtable_format, 2, 1, fp);
		fix_endianness(&subtable_format, 2);
		if (subtable_format != 4)
		{
			fprintf(stderr, "simple_ttf: cmap subtable not of format 4. Exiting.\n");
			exit(1);
		}

		/*
		 * The structure is as follows:
		 * 0x00-0x01: Format
		 * 0x02-0x03: Total subtable length
		 * 0x04-0x05: language code
		 * 0x06-0x07: segcount times two
		 * 0x08-0x13: Binary search tools
		 */

		uint16_t length, language_code, segcountX2;
		fread(&length, 2, 1, fp);
		fread(&language_code, 2, 1, fp);
		fread(&segcountX2, 2, 1, fp);
		fix_endianness(&length, 2);
		fix_endianness(&language_code, 2);
		fix_endianness(&segcountX2, 2);
		fseek(fp, 6, SEEK_CUR);
		
		/*
		 * The structure from here is as follows:
		 * uint16_t endCode[segcount]
		 * uint16_t reserved_pad
		 * uint16_t startCode[segcount]
		 * int16_t idDelta[segcount]
		 * uint16_t idRangeOffset[segcount]
		 */

		output.segcountX1 = segcountX2 / 2;
		output.endcodes = (uint16_t*) malloc(segcountX2);
		output.startcodes = (uint16_t*) malloc(segcountX2);
		output.id_deltas = (uint16_t*) malloc(segcountX2); 

		for (int i=0; i<segcountX2; i+=2)
		{
			fread(&(output.endcodes[i]), 2, 1, fp);
			fix_endianness(&(output.endcodes[i]), 2);
		}

		// Skip the reserved_pad
		fseek(fp, 2, SEEK_CUR);

		for (int i=0; i<segcountX2; i+=2)
		{
			fread(&(output.startcodes[i]), 2, 1, fp);
			fix_endianness(&(output.startcodes[1]), 2);
		}

		for (int i=0; i<segcountX2; i+=2)
		{
			fread(&(output.id_deltas[i]), 2, 1, fp);
			fix_endianness(&(output.id_deltas[i]), 2);
		}

		{ // We will not currently support id_range_offset == 1. Check.
			uint16_t id_range_offset;
			for (int i=0; i<segcountX2; i+=2)
			{
				fread(&id_range_offset, 2, 1, fp);
				fix_endianness(&id_range_offset, 2);
				if (id_range_offset != 0)
				{
					fprintf(stderr, "simple_ttf: nonzero id_range_offset not supported. Exiting.\n");
					exit(1);
				}
			}
		} // End verifying that all id_range_offset are zero.

	} // End parsing the subtable.

	return output;
}

static uint16_t glyph_index(char c, struct cmap_indices cmap)
{
	// First we need to locate the char. We will do a basic search.
	// First we will find the endcode above the char, most near to it.
	// Then we will check to verify that the startCode most near to it is at the same index.
	
	uint16_t c_int = (uint16_t) c;
	uint16_t c_segment;
	uint16_t glyph_index;

	{ // Search for the correct segment
		uint16_t closest_endcode_i = 0;
		uint16_t closest_startcode_i = 0;

		for(int i=0; i<cmap.segcountX1; ++i)
		{
			if(cmap.endcodes[i] >= c_int && 
					cmap.endcodes[i] < cmap.endcodes[closest_endcode_i])
			{
				closest_endcode_i = i;
			}

			if(cmap.startcodes[i] <= c_int && 
					cmap.startcodes[i] > cmap.startcodes[closest_startcode_i])
			{
				closest_startcode_i = i;
			}
		}

		if (closest_endcode_i != closest_startcode_i)
		{
			fprintf(stderr, "simple_ttf: error finding the segment for char %c. Exiting.\n", c);
			exit(1);
		}

		c_segment = closest_endcode_i;
	} // End searching for the correct segment
	
	glyph_index = c_int + cmap.id_deltas[c_segment];
	return glyph_index;
}

static struct EBLC_information parse_EBLC(uint16_t glyph_index, uint8_t font_px, struct header_contents header, FILE *fp)
{
	fseek(fp, header.offset_EBLC, SEEK_SET);
	
	{ // Check version numbers are in order.
		uint16_t major_version, minor_version;
		fread(&major_version, 2, 1, fp);
		fread(&minor_version, 2, 1, fp);
		fix_endianness(&major_version, 2);
		fix_endianness(&minor_version, 2);

		if(!(major_version == 2 && minor_version ==0))
		{
			fprintf(stderr, "simple_ttf: unsupported EBLC table version. Exiting.\n");
			exit(1);
		}
	} // End checking version numbers

	uint32_t num_of_bitmap_sizes;
	fread(&num_of_bitmap_sizes, 4, 1, fp);
	fix_endianness(&num_of_bitmap_sizes, 4);

	/*
	 * After this starts each 48 byte long bitmapsize record.
	 * We want to first find the correct bitmapsize record for this font strike size.
	 * There is only one record per strike size. We will also verify that the 
	 * glyph index is also in the provided range.
	*/
	uint32_t index_subtable_array_offset;
	uint32_t index_subtable_array_size;
	uint32_t number_of_index_subtables;
	uint32_t correct_subtable_index;
	{ // Finding the correct bitmapsize record
		uint32_t colorref_reserved;
		// Skip 24 bytes.
		uint16_t start_glyph_index;
		uint16_t end_glyph_index;
		uint8_t ppemX;
		uint8_t ppemY;
		uint8_t bit_depth;
		uint8_t flags;

		bool found=false;
		for (int i=0; i<num_of_bitmap_sizes; ++i)
		{
			fread(&index_subtable_array_offset, 4, 1, fp);
			fread(&index_subtable_array_size, 4, 1, fp);
			fread(&number_of_index_subtables, 4, 1, fp);
			fread(&colorref_reserved, 4, 1, fp);
			fseek(fp, 24, SEEK_CUR);
			fread(&start_glyph_index, 2, 1, fp);
			fread(&end_glyph_index, 2, 1, fp);
			fread(&ppemX, 1, 1, fp);
			fread(&ppemY, 1, 1, fp);
			fread(&bit_depth, 1, 1, fp);
			fread(&flags, 1, 1, fp);
			fix_endianness(&index_subtable_array_offset, 4);
			fix_endianness(&index_subtable_array_size, 4);
			fix_endianness(&number_of_index_subtables, 4);
			fix_endianness(&colorref_reserved, 4);
			fix_endianness(&start_glyph_index, 2);
			fix_endianness(&end_glyph_index, 2);
			
			if(ppemY != font_px)
			{
				continue;
			}

			if(colorref_reserved != 0)
			{
				fprintf(stderr, "simple_ttf: damaged EBLC table. Exiting.\n");
				exit(1);
			}

			if (!(start_glyph_index <= glyph_index && glyph_index <= end_glyph_index))
			{
				fprintf(stderr, "simple_ttf: no %hu glyph found in %u pt font. Exiting.\n", glyph_index, font_px);
				exit(1);
			}

			// We found it.
			correct_subtable_index = i;
			found = true;
		}

		if (!found)
		{
			fprintf(stderr, "simple_ttf: unable to find the desired %u font pt. Exiting.\n", font_px);
			exit(1);
		}
	} // End Finding the correct bitmapsize record.
	
	// Go to the corresponding index_subtable_array_offset.
	fseek(fp, header.offset_EBLC + index_subtable_array_offset, SEEK_SET);

	/* This is just an array of index_subtable records, which goes:
	 * uint16_t firstGlyphIndex
	 * uint16_t lastGlyphIndex
	 * uint32_t index_subtable_offset
	 * Notably: 
	 * Records must be sorted by firstGlyphIndex, and records should not have overlapping glyph ID ranges.
	 */

	// This offset is from the start of the index_subtable_array.
	uint32_t correct_index_subtable_offset;
	uint16_t correct_first_glyph_index;
	{ // Finding the correct index_subtable
		uint16_t last_glyph_index;
		uint32_t correct_subtable_index;
		bool found = false;

		// Check each interval to see if the glyph index is inside.
		for(int i=0; i<number_of_index_subtables; ++i)
		{
			fread(&correct_first_glyph_index, 2, 1, fp);
			fread(&last_glyph_index, 2, 1, fp);
			fread(&correct_index_subtable_offset, 4, 1, fp);
			fix_endianness(&correct_first_glyph_index, 2);
			fix_endianness(&last_glyph_index, 2);
			fix_endianness(&correct_index_subtable_offset, 4);
			
			if(correct_first_glyph_index <= glyph_index && glyph_index <= last_glyph_index)
			{
				found = true;
				break;
			}
		}
		if (!found)
		{
			fprintf(stderr, "simple_ttf: glyph_index not found within the index_subtable. Exiting.\n");
			exit(0);
		}
	} // End Finding the correct index_subtable
	
	// Go to the correct_index_subtable.
	fseek(fp, header.offset_EBLC + index_subtable_array_offset + correct_index_subtable_offset, SEEK_SET);

	// We need to now get the offset into the EBDT table. 
	struct EBLC_information output;
	{ // Parse the index subtable
		// Index subtable record is 2 uint16s, index_format and image_format, and a uint32, image_data_offset.
		uint16_t index_format;
		fread(&index_format, 2, 1, fp);
		fread(&output.image_format, 2, 1, fp);
		fread(&output.image_data_offset, 4, 1, fp);
		fix_endianness(&index_format, 2);
		fix_endianness(&output.image_format, 2);
		fix_endianness(&output.image_data_offset, 4);

		// Format 1 is the most common, so let's stick with that.
		if(index_format != 1)
		{
			fprintf(stderr, "simple_ttf: index subtable has index_format %hu, which is not supported. Exiting.\n", index_format);
			exit(1);
		}
		
		// Now, all we must do is get the EBDT offset.
		uint32_t sbit_offset_array_index = glyph_index - correct_first_glyph_index;
		fseek(fp, 4*sbit_offset_array_index, SEEK_CUR);
		fread(&output.sbit_offset, 4, 1, fp);
		fix_endianness(&output.sbit_offset, 4);
	} // End parsing the index subtable
	
	return output;
}

static struct pixel_data read_EBDT(struct EBLC_information eblc, struct header_contents header, FILE *fp)
{
	fseek(fp, header.offset_EBDT, SEEK_SET);
	{ // Check versioning
		uint16_t major_version;
		uint16_t minor_version;
		fread(&major_version, 2, 1, fp);
		fread(&minor_version, 2, 1, fp);
		fix_endianness(&major_version, 2);
		fix_endianness(&minor_version, 2);

		if(!(major_version == 2 && minor_version == 0))
		{
			fprintf(stderr, "simple_ttf: unsupported EBDT versions. Exiting.\n");
			exit(1);
		}
	} // End Checking versioning
	
	// Let's go to the correct spot in the EBDT table.
	fseek(fp, header.offset_EBDT +  eblc.image_data_offset + eblc.sbit_offset, SEEK_SET);

	// We will handle image format 2 for now.
	if(eblc.image_format != 2)
	{
		fprintf(stderr, "simple_ttf: Image format %hu in EBDT is unsupported. Exiting.\n", eblc.image_format);
		exit(1);
	}

	// Prepare the output
	struct pixel_data out;

	// Now let's read the SmallGlyphMetricsRecord
	{ // Reading the SmallGlyphMetricsRecord
		int8_t bearingX;
		int8_t bearingY;
		uint8_t advance;

		fread(&out.height, 1, 1, fp);
		fread(&out.width, 1, 1, fp);
		fread(&bearingX, 1, 1, fp);
		fread(&bearingY, 1, 1, fp);
		fread(&advance, 1, 1, fp);
	} // End Reading the SmallGlyphMetricsRecord.
	
	// Now, we need to actually read the bits. There are bmp_width columns and out.height rows.
	// The rows are placed sequentially, and do not wait for byte boundaries.

	// We just need to extract all the data. We know there is bmp_width * out.height pixels, and we need
	// to ensure it is divisible by 8 to fit in a byte.
	out.bytes_to_read = ceil( (float)(out.width*out.height)/8.0f );
	out.pixel_data = (uint8_t*) malloc(out.bytes_to_read);
	
	fread(out.pixel_data, 1, out.bytes_to_read, fp);
	fix_endianness(out.pixel_data, out.bytes_to_read);

	return out;
}

static void print_binary(uint8_t *pd, uint16_t bytes_to_read)
{
	uint8_t byte;
	uint32_t binary_text;
	for(int i=0; i<bytes_to_read; ++i)
	{
		binary_text = 0;
		byte = pd[i];
		for(int j=7; j>=0;--j)
		{
			if (byte >= (1<<j))
			{
				binary_text += (uint32_t) pow(10, j);
				byte -= (1u<<j);
			}
		}
		
		printf("%08u ", binary_text);
	}
	printf("\n");
}

void read_ttf(const char *filename)
{
	FILE *fp = fopen(filename, "rb");
	if (!fp)
	{
		fprintf(stderr, "simple_ttf: failed to open %s. \n", filename);
		exit(1);
	}

	struct header_contents header = S_TTF_read_header(fp);
	struct cmap_indices cmap =  parse_cmap(header, fp);
	uint16_t glyph = glyph_index('m', cmap);
	printf("%hu \n", glyph);
	struct EBLC_information eblc = parse_EBLC(glyph, 8, header, fp);
	struct pixel_data pd = read_EBDT(eblc, header, fp);
	
	fix_endianness(pd.pixel_data, pd.bytes_to_read);
	print_binary(pd.pixel_data, pd.bytes_to_read);
	printf("%d %d \n", pd.height, pd.width);


	fclose(fp);
}




int main()
{
	read_ttf("resources/Pixolletta8px2.ttf");	

}
